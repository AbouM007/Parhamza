app.post(
  "/api/professional-accounts/verify",
  // ‚¨ÖÔ∏è passe en multi-fichiers : 1 KBIS + 1 PDF CIN OU 2 images (recto/verso)
  upload.fields([
    { name: "kbis_document", maxCount: 1 },
    { name: "cin_document",  maxCount: 2 },
  ]),
  async (req, res) => {
    try {
      console.log("üè¢ V√©rification compte professionnel...");
      console.log("üìÑ Donn√©es re√ßues:", req.body);

      const {
        company_name,
        siret,
        company_address,
        phone,
        email,
        website,
        description,
      } = req.body;

      // 1) Validations de base
      if (!company_name || !siret) {
        return res.status(400).json({ error: "Champs obligatoires manquants" });
      }
      if (!/^\d{14}$/.test(siret)) {
        return res.status(400).json({ error: "SIRET invalide (14 chiffres requis)" });
      }

      // 2) Auth Supabase (identique √† ton code)
      const authHeader = req.headers.authorization;
      if (!authHeader) {
        return res.status(401).json({ error: "Token d'authentification manquant" });
      }
      const token = authHeader.replace("Bearer ", "");
      const { data: { user }, error: authError } = await supabaseServer.auth.getUser(token);
      if (authError || !user) return res.status(401).json({ error: "Token invalide" });

      // 3) Compte pro existant
      const { data: existingAccount, error: findAccErr } = await supabaseServer
        .from("professional_accounts")
        .select("id, company_name, siret, company_address")
        .eq("user_id", user.id)
        .single();

      if (findAccErr || !existingAccount) {
        return res.status(400).json({
          error: "Aucun compte professionnel trouv√©. Cr√©ez d'abord votre compte professionnel.",
        });
      }

      // 4) Unicit√© SIRET (hors soi)
      const { data: existingSiret } = await supabaseServer
        .from("professional_accounts")
        .select("id")
        .eq("siret", siret)
        .neq("id", existingAccount.id)
        .single();

      if (existingSiret) {
        return res.status(400).json({ error: "Ce num√©ro SIRET est d√©j√† utilis√© par un autre compte" });
      }

      // 5) Mise √† jour des infos pro (‚ö†Ô∏è NE MET PLUS AUCUNE COLONNE 'verification_status' ici)
      const { data: proAccount, error: proError } = await supabaseServer
        .from("professional_accounts")
        .update({
          company_name,
          siret,
          company_address: company_address ?? null,
          phone: phone ?? null,
          email: email ?? null,
          website: website ?? null,
          // status sera mis plus bas apr√®s inspection des documents
          updated_at: new Date().toISOString(),
        })
        .eq("id", existingAccount.id)
        .select()
        .single();

      if (proError) {
        console.error("‚ùå Erreur mise √† jour compte pro:", proError);
        return res.status(500).json({ error: "Erreur lors de la mise √† jour du compte professionnel" });
      }
      console.log("‚úÖ Compte professionnel mis √† jour:", proAccount.id);

      // 6) FICHIERS (multi)
      const files = req.files as Record<string, Express.Multer.File[]>;
      const kbis = files?.kbis_document?.[0];
      const cin  = files?.cin_document ?? [];

      // ‚úÖ Validation stricte sur les fichiers
      if (!kbis) {
        return res.status(400).json({ error: "Le document KBIS est requis" });
      }
      const cinIsPdf    = cin.length === 1 && cin[0].mimetype === "application/pdf";
      const cinIsImages = cin.length === 2 && cin.every(f => f.mimetype.startsWith("image/"));
      if (!cinIsPdf && !cinIsImages) {
        return res.status(400).json({ error: "La CIN doit √™tre 1 PDF ou 2 images (recto/verso)" });
      }

      // Helper d'upload Supabase Storage (‚ö†Ô∏è remplace le bucket/chemin si besoin)
      async function uploadToStorage(file: Express.Multer.File, proId: number, kind: string) {
        const ext = file.originalname.includes(".") ? file.originalname.split(".").pop() : "bin";
        const fileName = `${kind}-${proId}-${Date.now()}.${ext}`;
        const { data: up, error: upErr } = await supabaseServer.storage
          .from("vehicle-images") // <-- ton bucket actuel
          .upload(`documents/${fileName}`, file.buffer, {
            contentType: file.mimetype,
            upsert: false,
          });
        if (upErr) throw upErr;
        return { path: up.path, name: file.originalname, size: file.size };
      }

      // 7) Remplacement atomique des documents (supprime anciens types -> ins√®re nouveaux)
      // Types √† remplacer selon format de la CIN
      const typesToReplace = ["kbis", ...(cinIsPdf ? ["id_pdf"] : ["id_front", "id_back"])];

      // a) delete anciens docs de ces types pour ce compte pro
      const { error: delErr } = await supabaseServer
        .from("verification_documents")
        .delete()
        .eq("professional_account_id", proAccount.id)
        .in("document_type", typesToReplace);
      if (delErr) {
        console.error("‚ùå Erreur suppression anciens documents:", delErr);
        return res.status(500).json({ error: "Erreur lors du remplacement des documents" });
      }

      // b) upload + insert des nouveaux
      const inserts: any[] = [];

      // KBIS
      try {
        const up = await uploadToStorage(kbis, proAccount.id, "kbis");
        inserts.push({
          professional_account_id: proAccount.id,
          document_type: "kbis",
          file_url: up.path,
          file_name: up.name,
          file_size: up.size,
          verification_status: "pending",
        });
      } catch (e) {
        console.error("‚ùå Upload KBIS:", e);
        return res.status(500).json({ error: "√âchec upload KBIS" });
      }

      // CIN
      try {
        if (cinIsPdf) {
          const up = await uploadToStorage(cin[0], proAccount.id, "cin-pdf");
          inserts.push({
            professional_account_id: proAccount.id,
            document_type: "id_pdf",
            file_url: up.path,
            file_name: up.name,
            file_size: up.size,
            verification_status: "pending",
          });
        } else {
          const upFront = await uploadToStorage(cin[0], proAccount.id, "cin-front");
          const upBack  = await uploadToStorage(cin[1], proAccount.id, "cin-back");
          inserts.push(
            {
              professional_account_id: proAccount.id,
              document_type: "id_front",
              file_url: upFront.path,
              file_name: upFront.name,
              file_size: upFront.size,
              verification_status: "pending",
            },
            {
              professional_account_id: proAccount.id,
              document_type: "id_back",
              file_url: upBack.path,
              file_name: upBack.name,
              file_size: upBack.size,
              verification_status: "pending",
            }
          );
        }
      } catch (e) {
        console.error("‚ùå Upload CIN:", e);
        return res.status(500).json({ error: "√âchec upload CIN" });
      }

      const { error: insErr } = await supabaseServer
        .from("verification_documents")
        .insert(inserts);
      if (insErr) {
        console.error("‚ùå Erreur enregistrement documents:", insErr);
        return res.status(500).json({ error: "Erreur enregistrement des documents" });
      }

      // 8) Recalcul du statut: KBIS + (CIN pdf OU recto+verso) => under_review, sinon pending_docs
      //    (Si tu as ProfessionalStatusService en version Supabase, appelle-le ici.)
      const { data: docs, error: docsErr } = await supabaseServer
        .from("verification_documents")
        .select("document_type")
        .eq("professional_account_id", proAccount.id)
        .in("document_type", ["kbis","id_pdf","id_front","id_back"]);

      if (docsErr) {
        console.error("‚ùå Erreur lecture documents:", docsErr);
        return res.status(500).json({ error: "Erreur lecture des documents" });
      }

      const hasKbis = docs?.some(d => d.document_type === "kbis");
      const hasCinPdf = docs?.some(d => d.document_type === "id_pdf");
      const hasCinImgs = docs?.some(d => d.document_type === "id_front") &&
                         docs?.some(d => d.document_type === "id_back");
      const hasCin = !!(hasCinPdf || hasCinImgs);

      const nextStatus = hasKbis && hasCin ? "under_review" : "pending_docs";

      const { error: statusErr } = await supabaseServer
        .from("professional_accounts")
        .update({ status: nextStatus })
        .eq("id", proAccount.id);
      if (statusErr) {
        console.error("‚ùå Erreur MAJ statut:", statusErr);
        return res.status(500).json({ error: "Erreur mise √† jour du statut" });
      }

      // 9) (Optionnel) Profil pro initial si description fournie
      if (description) {
        const { error: profileError } = await supabaseServer
          .from("professional_profiles")
          .insert({
            professional_account_id: proAccount.id,
            description: description,
          });
        if (profileError) {
          console.error("‚ùå Erreur cr√©ation profil:", profileError);
        }
      }

      return res.json({
        success: true,
        status: nextStatus,
        completeness: { hasKbis: !!hasKbis, hasCin: !!hasCin },
        professionalAccountId: proAccount.id,
        message:
          nextStatus === "under_review"
            ? "Documents re√ßus. Votre dossier passe en revue."
            : "Documents incomplets. Merci de fournir la CIN (PDF ou recto/verso).",
      });
    } catch (error) {
      console.error("‚ùå Erreur v√©rification compte professionnel:", error);
      return res.status(500).json({ error: "Erreur serveur lors de la v√©rification" });
    }
  }
);
