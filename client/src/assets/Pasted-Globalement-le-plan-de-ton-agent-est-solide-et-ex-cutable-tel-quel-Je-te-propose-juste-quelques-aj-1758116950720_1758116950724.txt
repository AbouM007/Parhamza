Globalement, le plan de ton agent est solide et exÃ©cutable tel quel.
Je te propose juste quelques ajustements et ajouts pour Ã©viter les piÃ¨ges, plus un mini checklist par Ã©tape.

Mon verdict rapide

âœ… Bonne dÃ©composition (API multi-fichiers avant lâ€™UX front, StatusService centralisÃ©).

âœ… Compatible avec ce que tu as dÃ©jÃ  fait (ENUMs, service).

ğŸ”§ Ã€ peaufiner : contraintes DB/RLS, idempotence des uploads, et la centralisation (Ã©tape 5) Ã  sÃ©curiser pour ne pas casser lâ€™affichage.

6 amÃ©liorations concrÃ¨tes

IntÃ©grer le StatusService dÃ¨s lâ€™Ã©tape 3 (API)
Au lieu dâ€™attendre lâ€™Ã©tape 6, appelle dÃ©jÃ  updateStatusAfterUpload() dans /verify. Ã‡a garantit que le statut est â€œsource de vÃ©ritÃ©â€ dÃ¨s les premiers tests.

Idempotence & unicitÃ© documents
Ajoute une contrainte unique pour Ã©viter les doublons si lâ€™utilisateur renvoie plusieurs fois :

unique (professional_account_id, document_type)

et cÃ´tÃ© code : upsert (delete-then-insert si lâ€™ORM ne fait pas dâ€™upsert).

RLS & storage

VÃ©rifie les policies sur verification_documents (owner en lecture/Ã©criture) + rÃ´le admin.

VÃ©rifie que la bucket est privÃ©e et que lâ€™admin utilise des URL signÃ©es.

Centralisation (Ã©tape 5) sans douleur
Deux options sÃ»res :

A. Transition douce : pendant 1 sprint, Ã©cris dans users et professional_accounts (legacy) â†’ lis toujours depuis users (activÃ© via un petit flag/const).

B. View SQL : crÃ©e une view pro_company_view qui expose company_name/siret depuis users pour les lectures legacy â†’ zÃ©ro changement cÃ´tÃ© front/queries existantes.

Indexes utiles

verification_documents (professional_account_id, document_type)

professional_accounts (user_id) si absent.

UX validations claires

Step 2 : bloquer submit si KBIS manquant ou CIN incomplÃ¨te (1 PDF ou recto+verso).

Toast/message cÃ´tÃ© front qui explique quoi manque.

Ordre proposÃ© (lÃ©ger tweak)

Ã‰tape 1 (LSP) âœ…

Ã‰tape 3 (API multi-fichiers + StatusService direct) âœ…

Ã‰tape 2 (prÃ©-paiement simplifiÃ©)

Ã‰tape 4 (post-paiement complet + uploads)

Ã‰tape 6 (remplacer lectures par StatusService partout) â†’ tu en auras dÃ©jÃ  une partie via lâ€™Ã©tape 3

Ã‰tape 5 (centralisation users) â†’ fais A (double-write) ou B (view)

Ã‰tape 7 (UX admin)

Checklists rapides par Ã©tape

Ã‰tape 3 â€“ API

 upload.fields([{ name:'kbis_document', maxCount:1 }, { name:'cin_document', maxCount:2 }])

 DÃ©tection : 1 PDF â†’ id_pdf ; 2 images â†’ id_front + id_back

 upsert dans verification_documents (unicitÃ© par (pro_account_id, doc_type))

 ProfessionalStatusService.updateStatusAfterUpload(proAccountId)

 Retour JSON : { ok:true, status, completeness }

Ã‰tape 2 & 4 â€“ Front

 Step 1 = name + phone seulement (update users, set type=professional/pending)

 Step 2 = companyName, siret + uploads kbis + cin (1 ou 2 fichiers)

 Validation stricte + messages clairs

 Loader et Ã©vitement double submit

Ã‰tape 5 â€“ Centralisation

 Ã‰criture company_name/siret dans users

 (Option A) Double-write aussi dans professional_accounts pour compat

 (Option B) View SQL pour les lectures legacy

 Remplacer progressivement les lectures par users

Ã‰tape 6 â€“ StatusService partout

 Remplacer isVerified/verificationProcessStatus par getCompleteStatus()

 CÃ´tÃ© crÃ©ation dâ€™annonce : si status !== 'verified' â†’ annonces.status = 'pending'

Ã‰tape 7 â€“ Admin

 Grouper id_front + id_back â†’ â€œCIN (recto/verso)â€

 Bouton â€œValider la demandeâ€ â†’ setAdminDecision('verified'|'rejected')

 Lien â€œouvrirâ€ via URL signÃ©e

Petits risques Ã  surveiller

Multer en mÃ©moire vs disque : garantit la stabilitÃ© pour fichiers 20 MB+.

RÃ©-upload : dÃ©cide si tu remplaces (delete + insert) ou si tu versionnes (colonne version).

RÃ©gressions front : mets un feature flag (READ_COMPANY_FROM_USERS = true) pour basculer proprement.

Exemples de messages de commit (courts)

feat(api): support multi-file verify (kbis+cin) + status service call

feat(front): pro step1 simplified to name+phone only

feat(front): pro step2 adds company fields + CIN upload + strict validation

chore(db): add unique idx on verification_documents (pro_id, doc_type)

refactor(status): replace legacy checks with ProfessionalStatusService

feat(data): double-write company_name/siret to users (transition phase)