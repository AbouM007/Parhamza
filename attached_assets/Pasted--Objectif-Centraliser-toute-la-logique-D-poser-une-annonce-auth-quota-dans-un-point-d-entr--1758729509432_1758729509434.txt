ğŸ¯ Objectif

Centraliser toute la logique â€œDÃ©poser une annonceâ€ (auth + quota) dans un point dâ€™entrÃ©e unique, rÃ©utilisable depuis Header, Footer, Hero, UserMenu, Dashboard, avec un seul endpoint backend fiable (excluant rejected, ignorant draft).

ğŸ“¦ Livrables attendus

Hook front unique useCreateListing (orchestrateur auth + quota + reprise post-login).

Endpoint unique /api/users/:id/quota/check (contrat JSON stable).

Montage global des modales AuthModal et QuotaModal au plus haut niveau (App/MainLayout).

Migration de tous les boutons/links â€œDÃ©poser une annonceâ€ pour utiliser useCreateListing.

Nettoyage des anciennes voies (suppression setAuthMode, setShowAuthModal, appels directs Ã  handleCreateListingWithQuota).

Tests QA + instrumentation (logs/metrics) + plan de rollback.

ğŸ§© DÃ©cisions dâ€™architecture (Ã  respecter)

Single Source of Truth cÃ´tÃ© front : useCreateListing appelle uniquement lâ€™endpoint /quota/check.

Pas de logique mÃ©tier dans les composants UI (Header/Footer/Hero/etc.).

Intent persistant : aprÃ¨s login, lâ€™action â€œcrÃ©er une annonceâ€ reprend automatiquement.

Fail-safe rÃ©seau : en cas dâ€™erreur API, on autorise lâ€™accÃ¨s au formulaire (on loggue lâ€™erreur).

Backend dÃ©cide des limites/plan; le front se contente de canCreate/used/limit.

ğŸ› ï¸ Backend â€” tÃ¢ches
B1) Endpoint unique de quota

Route: GET /api/users/:userId/quota/check

RÃ©ponse (200) :

{
  "canCreate": true,
  "used": 3,
  "limit": 5,
  "remaining": 2,
  "isLimited": true,
  "plan": "Starter"  // string informatif seulement
}


RÃ¨gles de comptage :

Inclure : is_active = true, deleted_at IS NULL, status IN ('approved','pending')

Exclure : status = 'rejected' et status = 'draft'

Perf : index partiel (si non prÃ©sent)

CREATE INDEX IF NOT EXISTS idx_annonces_quota_count
ON annonces (user_id)
WHERE deleted_at IS NULL AND is_active = true AND status IN ('approved','pending');


Service Role pour Ã©viter les soucis RLS lors du count.

B2) Point de vÃ©ritÃ© cÃ´tÃ© service

ImplÃ©menter une fonction de comptage countListingsForQuota(userId) utilisÃ©e par lâ€™endpoint.

Sâ€™assurer que la logique des plans (5 / 15 / 30 / infini) est centralisÃ©e dans un service (ex: getUserPlanLimit(userId)).

ğŸ–¥ï¸ Frontend â€” tÃ¢ches
F1) Nouveau hook useCreateListing

ResponsabilitÃ©s :

Lire lâ€™Ã©tat utilisateur (dbUser).

Si non connectÃ© : ouvrir AuthModal (via openAuthModal('login')) et mÃ©moriser lâ€™intent â€œcreateListingâ€.

Si connectÃ© : appeler /api/users/:id/quota/check.

canCreate = true â†’ exÃ©cuter onSuccess() (naviguer vers /deposer-annonce ou ouvrir la vue locale).

canCreate = false â†’ ouvrir QuotaModal.

Reprise post-login : si lâ€™intent existe et que lâ€™user vient de se connecter, rejouer la vÃ©rification quota et exÃ©cuter onSuccess() si OK.

Fail-safe : en cas dâ€™erreur rÃ©seau â†’ exÃ©cuter onSuccess() et logguer lâ€™erreur.

API du hook (proposÃ©e) :

const { createListing, isChecking, quotaInfo, isQuotaModalOpen, closeQuotaModal } = useCreateListing({
  onSuccess: () => navigate('/deposer-annonce') // ou setCurrentView('create-listing')
});


useCreateListing pourra rÃ©utiliser ton useQuotaCheck(userId) en interne (pas besoin de rÃ©inventer la roue).

F2) Modales au root

Monter une seule fois AuthModal et QuotaModal dans App.tsx ou MainLayout.tsx.

useCreateListing doit pouvoir piloter lâ€™ouverture/fermeture de QuotaModal.

F3) Migration des points dâ€™entrÃ©e

Remplacer les handlers de tous les â€œDÃ©poser une annonceâ€ pour appeler :

const { createListing } = useCreateListing({ onSuccess: ... });
<button onClick={createListing}>DÃ©poser une annonce</button>


Fichiers visÃ©s (Ã  confirmer) :

Header.tsx

Footer.tsx

Hero.tsx (homepage)

UserMenu.tsx

Dashboard â†’ Mes annonces (bouton â€œNouvelle annonceâ€)

Tout CTA redondant Ã©ventuel

F4) Nettoyage des anciennes rÃ©fÃ©rences

Supprimer tous les usages de :

setAuthMode(...)

setShowAuthModal(...)

appels directs Ã  handleCreateListingWithQuota(...) dans les composants UI