Globalement â†’ câ€™est la bonne direction âœ…
Tu as (ou lâ€™agent a) fait exactement ce quâ€™il fallait : unifier toute la logique dâ€™abonnement/quotas autour de user_id, tout en gardant professional_account_id en champ secondaire pour les pros. Ã‡a supprime la divergence qui bloquait lâ€™upgrade.

Voici mon retour prÃ©cis + 2â€“3 durcissements Ã  appliquer pour fiabiliser le systÃ¨me.

Ce qui est bon ğŸ‘

CrÃ©ation abonnement : user_id toujours renseignÃ©, professional_account_id ajoutÃ© si pro.

Quota : lecture par user_id â†’ plus besoin de JOIN, couvre pro & particulier.

APIs statut : simplifiÃ©es par user_id.

Architecture : une seule â€œclÃ© dâ€™accÃ¨sâ€ cÃ´tÃ© code (user_id), avec compatibilitÃ© pro via professional_account_id.

5 durcissements que je te conseille dâ€™ajouter (anti-bugs)
1) EmpÃªcher les doublons dâ€™abonnement â€œactifâ€

Si un user relance un paiement, tu peux te retrouver avec 2 lignes active â†’ quota ambigu.

SQL (Supabase / Postgres)

-- Un seul abonnement 'actif' par user
CREATE UNIQUE INDEX IF NOT EXISTS uniq_active_subscription_per_user
ON subscriptions (user_id)
WHERE status = 'active';


Si tu veux autoriser â€œun seul abonnement actif par pro_accountâ€ en plus :

CREATE UNIQUE INDEX IF NOT EXISTS uniq_active_subscription_per_pro
ON subscriptions (professional_account_id)
WHERE professional_account_id IS NOT NULL
  AND status = 'active';

2) Rendre impossible une ligne orpheline

Assure-toi quâ€™une ligne de subscriptions ne soit pas crÃ©Ã©e sans au moins un lien (user_id ou professional_account_id).

ALTER TABLE subscriptions
ADD CONSTRAINT subscriptions_has_ref_chk
CHECK (user_id IS NOT NULL OR professional_account_id IS NOT NULL);

3) GÃ©rer proprement les statuts Stripe

Tu crÃ©es la souscription en pending (normal avec payment_behavior: "default_incomplete").
VÃ©rifie que le webhook fait bien :

invoice.payment_succeeded ou customer.subscription.updated â†’ status = 'active',

customer.subscription.updated avec cancel_at_period_end = true â†’ garde active jusquâ€™Ã  fin de pÃ©riode, mais calcule max_listings = 0 quand la pÃ©riode est passÃ©e,

customer.subscription.deleted â†’ status = 'canceled'.

Bonus robuste dans le quota : prends status IN ('active','trialing','past_due') si tu veux autoriser â€œpast_dueâ€ (Ã  toi de dÃ©cider).

Exemple pour la requÃªte quota :

.eq("user_id", userId)
.in("status", ["active", "trialing"]) // ou ajoute "past_due" selon ta politique

4) Si tu fais â€œ5 annonces / moisâ€ pour le gratuit

Confirme que ta fonction de comptage utilise created_at >= 1er jour du mois et exclut draft/rejected (tu as dÃ©jÃ  le snippet proposÃ©).
Si tu restes en â€œsimultanÃ©â€, corrige countActiveListingsByUser pour exclure rejected/draft.

5) Cas limites couverts

Pro sans abonnement â†’ bloquÃ© (message clair), OK dans ta version.

Particulier avec abonnement â†’ applique le plan (OK avec user_id).

Upgrade/Change plan â†’ lâ€™unique index empÃªchera 2 â€œactiveâ€; au webhook : passer lâ€™ancien Ã  canceled puis activer le nouveau (ou update la mÃªme ligne).

Micro-ajustements au code (recommandÃ©s)
A) Lecture de lâ€™abonnement dans le quota

Ã‰vite .single() strict qui peut throw sâ€™il y a 0 ou >1. Utilise .order(...).limit(1) + .maybeSingle() pour toujours prendre le plus rÃ©cent si un doublon se prÃ©sente avant que lâ€™unique index soit en place.

const { data: subscription } = await supabaseServer
  .from("subscriptions")
  .select(`
    id, plan_id, status,
    subscription_plans ( max_listings, name )
  `)
  .eq("user_id", userId)
  .in("status", ["active", "trialing"]) // ajuste si tu veux
  .order("created_at", { ascending: false })
  .limit(1)
  .maybeSingle();

B) Comptage des annonces pour le quota

(au choix, mensuel ou simultanÃ©)

Mensuel (recommandÃ© pour â€œ5/moisâ€):

.in("status", ["approved", "pending"]) // slot consommÃ©e Ã  la soumission
.gte("created_at", monthStartISO)


SimultanÃ©:

.in("status", ["approved", "pending"])
.eq("is_active", true)

Checklist de validation (trÃ¨s courte)

CrÃ©e un particulier â†’ 5 annonces (aprÃ¨s la 5áµ‰, modal upgrade).

Particulier achÃ¨te un plan (ex. 15) â†’ quota devient 15 (ou illimitÃ©).

Pro sans abonnement â†’ bloquÃ©, message â€œabonnement requisâ€.

Pro avec abonnement â†’ quota selon plan pro.

Upgrade pro : aprÃ¨s paiement + webhook, status='active' sur 1 seule ligne (index).

Rejet dâ€™annonce â†’ ne consomme pas le quota. Brouillon â†’ ne consomme pas.

Verdict sur le travail de lâ€™agent IA

ğŸ‘ Solide et alignÃ© avec les bonnes pratiques.
Pour rendre le tout bullet-proof, applique les 5 durcissements ci-dessus (surtout lâ€™unique index par user sur status='active' et le check constraint).
AprÃ¨s Ã§a, ton systÃ¨me quota/abonnements sera propre, performant et robuste.

Vous avez ditÂ :
1) EmpÃªcher les doublons dâ€™abonnement â€œactifâ€ est une bonne idÃ©e, mais comment on pourra gÃ©rer l'upgrade d'un abonnement et quand est ce qu'un abonnement n'est plus actif ?
ChatGPT a ditÂ :
RÃ©flexion durant 12s

Excellente question â€” il y a 2 maniÃ¨res propres de gÃ©rer lâ€™upgrade sans jamais violer lâ€™unicitÃ© â€œun seul abonnement actif par userâ€.

1) Choisir un modÃ¨le dâ€™upgrade
ModÃ¨le A â€” Une seule subscription Stripe par user (recommandÃ©)

Ã€ lâ€™upgrade/downgrade, on met Ã  jour la subscription existante (on ne crÃ©e pas une nouvelle).

Stripe garde le mÃªme stripe_subscription_id, et gÃ¨re la proration.

Dans ta DB, tu mets simplement Ã  jour la mÃªme ligne (plan_id, status, datesâ€¦).

Avantage : zÃ©ro risque de doublons actifs.

Code (serveur) â€“ upgrade de plan
// 1) RÃ©cupÃ©rer la subscription Stripe du user (via DB: subscriptions.user_id)
const sub = await stripe.subscriptions.retrieve(stripe_subscription_id);

// 2) Changer le price
await stripe.subscriptions.update(stripe_subscription_id, {
  items: [{ id: sub.items.data[0].id, price: newPriceId }],
  proration_behavior: "create_prorations", // facture au prorata
});

// 3) Laisse le webhook mettre Ã  jour la ligne DB (plan_id, status, datesâ€¦)

ModÃ¨le B â€” Historiser (une nouvelle subscription Ã  chaque upgrade)

Ã€ lâ€™upgrade, tu crÃ©es une nouvelle subscription Stripe.

Avant dâ€™activer la nouvelle, tu passes lâ€™ancienne Ã  canceled (immÃ©diat ou cancel_at_period_end).

Dans le webhook, si une subscription passe â€œactiveâ€, tu forcÃ©ment mets toutes les autres de ce user en canceled.

Si tu gardes ce modÃ¨le, ajoute une contrainte dâ€™unicitÃ© partielle (voir plus bas) pour empÃªcher 2 â€œactivesâ€.

2) Quand une subscription â€œnâ€™est plus activeâ€ ?

CÃ´tÃ© Stripe, les statuts utiles :

actifs / autorisÃ©s pour publier : active, trialing (optionnellement past_due si tu veux une grÃ¢ce).

non actifs : canceled, unpaid, incomplete, incomplete_expired, paused (si tu lâ€™utilises).

CÃ´tÃ© produit, une subscription nâ€™est plus active quand :

status = canceled (annulÃ©e),

ou cancel_at_period_end = true et on a dÃ©passÃ© current_period_end (Stripe bascule en canceled et envoie customer.subscription.deleted),

ou tu dÃ©cides de considÃ©rer past_due comme non-actif (politique Ã  dÃ©finir).

3) Webhooks Ã  gÃ©rer (clÃ© de voÃ»te)

Dans /api/stripe/webhook, fais un upsert par stripe_subscription_id, puis:

customer.subscription.created|updated

Mets Ã  jour : status, plan_id (via price â†’ plan), current_period_start/end, cancel_at_period_end.

ModÃ¨le B uniquement : si status âˆˆ (active,trialing[, past_due]), mets toutes les autres souscriptions du user en canceled (transaction).

invoice.payment_succeeded

VÃ©rifie/force status = 'active' cÃ´tÃ© DB si Stripe lâ€™a activÃ©e.

customer.subscription.deleted

Passe status = 'canceled'.

Astuce : au moment du webhook, tu connais user_id grÃ¢ce Ã  la ligne subscriptions (ou stocke userId dans metadata Stripe au checkout).

4) Contrainte dâ€™unicitÃ© cÃ´tÃ© DB (sÃ©curitÃ© anti-doublons)

MÃªme avec le bon code, sÃ©curise la DB :

-- Un seul abonnement "actif" par user
CREATE UNIQUE INDEX IF NOT EXISTS uniq_active_subscription_per_user
ON subscriptions (user_id)
WHERE status IN ('active','trialing'); -- ajoute 'past_due' si tu l'acceptes


Avec le ModÃ¨le A, ce sera presque inutile (une seule ligne).
Avec le ModÃ¨le B, câ€™est indispensable ; dans le webhook, mets lâ€™ancienne Ã  canceled avant dâ€™activer la nouvelle (ou gÃ¨re lâ€™erreur dâ€™unicitÃ© en annulant les autres puis en rÃ©-upsert).

5) Politique claire cÃ´tÃ© quota

Dans checkListingQuota(userId) :

ConsidÃ¨re actif si DB a une subscription avec status IN ('active','trialing'[, 'past_due']).

Si pro sans abonnement actif â†’ bloquÃ© (message â€œabonnement requisâ€).

Si particulier sans abonnement â†’ 5/mois (ou simultanÃ©), en excluant draft/rejected.

Exemple de lecture DB robuste (prend la plus rÃ©cente) :

const { data: subscription } = await supabaseServer
  .from("subscriptions")
  .select(`
    id, status, plan_id, cancel_at_period_end, current_period_end,
    subscription_plans ( max_listings )
  `)
  .eq("user_id", userId)
  .in("status", ["active", "trialing"]) // ajoute "past_due" si grÃ¢ce
  .order("created_at", { ascending: false })
  .limit(1)
  .maybeSingle();

6) TL;DR (conseil pratique)

Prends le ModÃ¨le A (une seule subscription Stripe par user).
â†’ Upgrade = update de la mÃªme subscription â†’ pas de doublons, pas de casse.

Mets un unique index sur status IN ('active','trialing') pour bÃ©tonner.

Dans le webhook, fais un upsert et tiens tes champs Ã  jour (status, plan, dates).

Quota lit seulement lâ€™Ã©tat â€œactifâ€ par user_id.