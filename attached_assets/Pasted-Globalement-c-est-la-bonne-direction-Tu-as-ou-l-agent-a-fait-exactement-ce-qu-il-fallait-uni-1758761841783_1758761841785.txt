Globalement → c’est la bonne direction ✅
Tu as (ou l’agent a) fait exactement ce qu’il fallait : unifier toute la logique d’abonnement/quotas autour de user_id, tout en gardant professional_account_id en champ secondaire pour les pros. Ça supprime la divergence qui bloquait l’upgrade.

Voici mon retour précis + 2–3 durcissements à appliquer pour fiabiliser le système.

Ce qui est bon 👍

Création abonnement : user_id toujours renseigné, professional_account_id ajouté si pro.

Quota : lecture par user_id → plus besoin de JOIN, couvre pro & particulier.

APIs statut : simplifiées par user_id.

Architecture : une seule “clé d’accès” côté code (user_id), avec compatibilité pro via professional_account_id.

5 durcissements que je te conseille d’ajouter (anti-bugs)
1) Empêcher les doublons d’abonnement “actif”

Si un user relance un paiement, tu peux te retrouver avec 2 lignes active → quota ambigu.

SQL (Supabase / Postgres)

-- Un seul abonnement 'actif' par user
CREATE UNIQUE INDEX IF NOT EXISTS uniq_active_subscription_per_user
ON subscriptions (user_id)
WHERE status = 'active';


Si tu veux autoriser “un seul abonnement actif par pro_account” en plus :

CREATE UNIQUE INDEX IF NOT EXISTS uniq_active_subscription_per_pro
ON subscriptions (professional_account_id)
WHERE professional_account_id IS NOT NULL
  AND status = 'active';

2) Rendre impossible une ligne orpheline

Assure-toi qu’une ligne de subscriptions ne soit pas créée sans au moins un lien (user_id ou professional_account_id).

ALTER TABLE subscriptions
ADD CONSTRAINT subscriptions_has_ref_chk
CHECK (user_id IS NOT NULL OR professional_account_id IS NOT NULL);

3) Gérer proprement les statuts Stripe

Tu crées la souscription en pending (normal avec payment_behavior: "default_incomplete").
Vérifie que le webhook fait bien :

invoice.payment_succeeded ou customer.subscription.updated → status = 'active',

customer.subscription.updated avec cancel_at_period_end = true → garde active jusqu’à fin de période, mais calcule max_listings = 0 quand la période est passée,

customer.subscription.deleted → status = 'canceled'.

Bonus robuste dans le quota : prends status IN ('active','trialing','past_due') si tu veux autoriser “past_due” (à toi de décider).

Exemple pour la requête quota :

.eq("user_id", userId)
.in("status", ["active", "trialing"]) // ou ajoute "past_due" selon ta politique

4) Si tu fais “5 annonces / mois” pour le gratuit

Confirme que ta fonction de comptage utilise created_at >= 1er jour du mois et exclut draft/rejected (tu as déjà le snippet proposé).
Si tu restes en “simultané”, corrige countActiveListingsByUser pour exclure rejected/draft.

5) Cas limites couverts

Pro sans abonnement → bloqué (message clair), OK dans ta version.

Particulier avec abonnement → applique le plan (OK avec user_id).

Upgrade/Change plan → l’unique index empêchera 2 “active”; au webhook : passer l’ancien à canceled puis activer le nouveau (ou update la même ligne).

Micro-ajustements au code (recommandés)
A) Lecture de l’abonnement dans le quota

Évite .single() strict qui peut throw s’il y a 0 ou >1. Utilise .order(...).limit(1) + .maybeSingle() pour toujours prendre le plus récent si un doublon se présente avant que l’unique index soit en place.

const { data: subscription } = await supabaseServer
  .from("subscriptions")
  .select(`
    id, plan_id, status,
    subscription_plans ( max_listings, name )
  `)
  .eq("user_id", userId)
  .in("status", ["active", "trialing"]) // ajuste si tu veux
  .order("created_at", { ascending: false })
  .limit(1)
  .maybeSingle();

B) Comptage des annonces pour le quota

(au choix, mensuel ou simultané)

Mensuel (recommandé pour “5/mois”):

.in("status", ["approved", "pending"]) // slot consommée à la soumission
.gte("created_at", monthStartISO)


Simultané:

.in("status", ["approved", "pending"])
.eq("is_active", true)

Checklist de validation (très courte)

Crée un particulier → 5 annonces (après la 5ᵉ, modal upgrade).

Particulier achète un plan (ex. 15) → quota devient 15 (ou illimité).

Pro sans abonnement → bloqué, message “abonnement requis”.

Pro avec abonnement → quota selon plan pro.

Upgrade pro : après paiement + webhook, status='active' sur 1 seule ligne (index).

Rejet d’annonce → ne consomme pas le quota. Brouillon → ne consomme pas.

Verdict sur le travail de l’agent IA

👍 Solide et aligné avec les bonnes pratiques.
Pour rendre le tout bullet-proof, applique les 5 durcissements ci-dessus (surtout l’unique index par user sur status='active' et le check constraint).
Après ça, ton système quota/abonnements sera propre, performant et robuste.

Vous avez dit :
1) Empêcher les doublons d’abonnement “actif” est une bonne idée, mais comment on pourra gérer l'upgrade d'un abonnement et quand est ce qu'un abonnement n'est plus actif ?
ChatGPT a dit :
Réflexion durant 12s

Excellente question — il y a 2 manières propres de gérer l’upgrade sans jamais violer l’unicité “un seul abonnement actif par user”.

1) Choisir un modèle d’upgrade
Modèle A — Une seule subscription Stripe par user (recommandé)

À l’upgrade/downgrade, on met à jour la subscription existante (on ne crée pas une nouvelle).

Stripe garde le même stripe_subscription_id, et gère la proration.

Dans ta DB, tu mets simplement à jour la même ligne (plan_id, status, dates…).

Avantage : zéro risque de doublons actifs.

Code (serveur) – upgrade de plan
// 1) Récupérer la subscription Stripe du user (via DB: subscriptions.user_id)
const sub = await stripe.subscriptions.retrieve(stripe_subscription_id);

// 2) Changer le price
await stripe.subscriptions.update(stripe_subscription_id, {
  items: [{ id: sub.items.data[0].id, price: newPriceId }],
  proration_behavior: "create_prorations", // facture au prorata
});

// 3) Laisse le webhook mettre à jour la ligne DB (plan_id, status, dates…)

Modèle B — Historiser (une nouvelle subscription à chaque upgrade)

À l’upgrade, tu crées une nouvelle subscription Stripe.

Avant d’activer la nouvelle, tu passes l’ancienne à canceled (immédiat ou cancel_at_period_end).

Dans le webhook, si une subscription passe “active”, tu forcément mets toutes les autres de ce user en canceled.

Si tu gardes ce modèle, ajoute une contrainte d’unicité partielle (voir plus bas) pour empêcher 2 “actives”.

2) Quand une subscription “n’est plus active” ?

Côté Stripe, les statuts utiles :

actifs / autorisés pour publier : active, trialing (optionnellement past_due si tu veux une grâce).

non actifs : canceled, unpaid, incomplete, incomplete_expired, paused (si tu l’utilises).

Côté produit, une subscription n’est plus active quand :

status = canceled (annulée),

ou cancel_at_period_end = true et on a dépassé current_period_end (Stripe bascule en canceled et envoie customer.subscription.deleted),

ou tu décides de considérer past_due comme non-actif (politique à définir).

3) Webhooks à gérer (clé de voûte)

Dans /api/stripe/webhook, fais un upsert par stripe_subscription_id, puis:

customer.subscription.created|updated

Mets à jour : status, plan_id (via price → plan), current_period_start/end, cancel_at_period_end.

Modèle B uniquement : si status ∈ (active,trialing[, past_due]), mets toutes les autres souscriptions du user en canceled (transaction).

invoice.payment_succeeded

Vérifie/force status = 'active' côté DB si Stripe l’a activée.

customer.subscription.deleted

Passe status = 'canceled'.

Astuce : au moment du webhook, tu connais user_id grâce à la ligne subscriptions (ou stocke userId dans metadata Stripe au checkout).

4) Contrainte d’unicité côté DB (sécurité anti-doublons)

Même avec le bon code, sécurise la DB :

-- Un seul abonnement "actif" par user
CREATE UNIQUE INDEX IF NOT EXISTS uniq_active_subscription_per_user
ON subscriptions (user_id)
WHERE status IN ('active','trialing'); -- ajoute 'past_due' si tu l'acceptes


Avec le Modèle A, ce sera presque inutile (une seule ligne).
Avec le Modèle B, c’est indispensable ; dans le webhook, mets l’ancienne à canceled avant d’activer la nouvelle (ou gère l’erreur d’unicité en annulant les autres puis en ré-upsert).

5) Politique claire côté quota

Dans checkListingQuota(userId) :

Considère actif si DB a une subscription avec status IN ('active','trialing'[, 'past_due']).

Si pro sans abonnement actif → bloqué (message “abonnement requis”).

Si particulier sans abonnement → 5/mois (ou simultané), en excluant draft/rejected.

Exemple de lecture DB robuste (prend la plus récente) :

const { data: subscription } = await supabaseServer
  .from("subscriptions")
  .select(`
    id, status, plan_id, cancel_at_period_end, current_period_end,
    subscription_plans ( max_listings )
  `)
  .eq("user_id", userId)
  .in("status", ["active", "trialing"]) // ajoute "past_due" si grâce
  .order("created_at", { ascending: false })
  .limit(1)
  .maybeSingle();

6) TL;DR (conseil pratique)

Prends le Modèle A (une seule subscription Stripe par user).
→ Upgrade = update de la même subscription → pas de doublons, pas de casse.

Mets un unique index sur status IN ('active','trialing') pour bétonner.

Dans le webhook, fais un upsert et tiens tes champs à jour (status, plan, dates).

Quota lit seulement l’état “actif” par user_id.