diff --git a/server/routes/subscriptions.ts b/server/routes/subscriptions.ts
index 1111111..2222222 100644
--- a/server/routes/subscriptions.ts
+++ b/server/routes/subscriptions.ts
@@
-import { Router } from "express";
+import { Router } from "express";
+import express from "express";
 import Stripe from "stripe";
 import { supabaseServer } from "../supabase";
 import { requireAuth } from "../middleware/auth";
 
 const router = Router();
 
@@
 const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
 
 /* --------------------------------- HELPERS -------------------------------- */
 
 async function mapPriceToPlanId(priceId: string): Promise<number | null> {
@@
 }
 
+async function upsertSubscriptionRow(row: {
+  user_id: string;
+  plan_id: number | null;
+  status: string | null;
+  stripe_subscription_id: string;
+  stripe_customer_id?: string | null;
+  current_period_start?: string | null;
+  current_period_end?: string | null;
+}) {
+  const payload = {
+    ...row,
+    updated_at: new Date().toISOString(),
+  };
+  const { error } = await supabaseServer
+    .from("subscriptions")
+    .upsert(payload, { onConflict: "stripe_subscription_id" });
+  if (error) throw error;
+}
+
 function tsToIso(tsSec?: number | null) {
   return tsSec ? new Date(tsSec * 1000).toISOString() : null;
 }
 
 /* ---------------------------- SUBSCRIPTION PLANS --------------------------- */
@@
 // POST /api/create-checkout-session - Cr√©er session Stripe Checkout
 router.post("/create-checkout-session", async (req, res) => {
   try {
-    const { planId, userEmail } = req.body;
-
-    if (!planId || !userEmail) {
-      return res.status(400).json({ error: "planId et userEmail sont requis" });
-    }
+    const { planId, userId, userEmail } = req.body;
+    // ‚ö†Ô∏è On exige userId (source de v√©rit√©). userEmail est facultatif.
+    if (!planId || !userId) {
+      return res.status(400).json({ error: "planId et userId sont requis" });
+    }
 
     const { data: plan, error: planError } = await supabaseServer
       .from("subscription_plans")
       .select("*")
       .eq("id", planId)
       .eq("is_active", true)
       .single();
@@
-    const session = await stripe.checkout.sessions.create({
-      payment_method_types: ["card"],
-      mode: "subscription",
-      line_items: [{ price: plan.stripe_price_id, quantity: 1 }],
-      customer_email: userEmail,
-      client_reference_id: req.body.userId, // ‚úÖ AJOUT
-      success_url: `${(process.env.FRONTEND_URL || "https://" + req.get("host"))}/success?session_id={CHECKOUT_SESSION_ID}`,
-      cancel_url: `${(process.env.FRONTEND_URL || "https://" + req.get("host"))}/plans`,
-      metadata: {
-        planId: String(planId),
-        userEmail,
-        userId: req.body.userId, // ‚úÖ AJOUT (ceinture et bretelles)
-        planName: plan.name,
-      },
-    });
+    const session = await stripe.checkout.sessions.create({
+      payment_method_types: ["card"],
+      mode: "subscription",
+      line_items: [{ price: plan.stripe_price_id, quantity: 1 }],
+      // On peut encore passer l'email pour l‚ÄôUX, mais la logique ne d√©pend plus de lui :
+      customer_email: userEmail || undefined,
+      // üîë Attache toujours userId
+      client_reference_id: String(userId),
+      metadata: {
+        user_id: String(userId),
+        plan_id: String(planId),
+        plan_name: plan.name,
+      },
+      subscription_data: {
+        metadata: {
+          user_id: String(userId),
+          plan_id: String(planId),
+          plan_name: plan.name,
+        },
+      },
+      success_url: `${(process.env.FRONTEND_URL || "https://" + req.get("host"))}/success?session_id={CHECKOUT_SESSION_ID}`,
+      cancel_url: `${(process.env.FRONTEND_URL || "https://" + req.get("host"))}/plans`,
+    });
 
 
     return res.json({ sessionUrl: session.url });
   } catch (error) {
     console.error("‚ùå Erreur cr√©ation session checkout:", error);
@@
 // POST /api/subscriptions/handle-success - Traiter le retour de succ√®s Stripe
 router.post("/handle-success", async (req, res) => {
   try {
     const { sessionId } = req.body;
     if (!sessionId) return res.status(400).json({ error: "Session ID manquant" });
 
-    const session = await stripe.checkout.sessions.retrieve(sessionId, { expand: ["subscription"] });
+    const session = await stripe.checkout.sessions.retrieve(sessionId, { expand: ["subscription", "customer"] });
     if (!session.subscription) {
       return res.status(400).json({ error: "Pas d'abonnement dans la session" });
     }
 
     // R√©cup Stripe sub + priceId
     const fullSub = await stripe.subscriptions.retrieve(session.subscription as string);
     const priceObj = fullSub.items.data[0].price as any;
     const priceId = typeof priceObj === "string" ? priceObj : priceObj.id;
 
-    // Trouver (ou cr√©er) l'utilisateur par email (table users)
-    const userEmail = session.customer_details?.email;
-    if (!userEmail) return res.status(400).json({ error: "Email client manquant" });
-
-    // Essayer d‚Äôabord de le trouver en DB
-    let { data: user, error: userError } = await supabaseServer
-      .from("users")
-      .select("id, email, name")
-      .eq("email", userEmail)
-      .maybeSingle();
-
-    // Si pas trouv√©, tenter via auth admin (puis cr√©er la ligne users)
-    if (!user) {
-      const { data: authUsers, error: authError } = await supabaseServer.auth.admin.listUsers();
-      if (authError || !authUsers.users) {
-        console.error("‚ùå Auth admin listUsers error:", authError);
-        return res.status(404).json({ error: "Utilisateur introuvable (auth)" });
-      }
-      const authUser = authUsers.users.find((u) => u.email === userEmail);
-      if (!authUser) return res.status(404).json({ error: "Utilisateur introuvable" });
-
-      const { data: createdUser, error: createError } = await supabaseServer
-        .from("users")
-        .insert({
-          id: authUser.id,
-          email: authUser.email!,
-          name: authUser.user_metadata?.name || authUser.email!.split("@")[0],
-          created_at: new Date().toISOString(),
-        })
-        .select("id, email, name")
-        .single();
-      if (createError) {
-        console.error("‚ùå Erreur cr√©ation utilisateur:", createError);
-        return res.status(500).json({ error: "Erreur cr√©ation utilisateur" });
-      }
-      user = createdUser;
-    }
+    // ‚úÖ Source de v√©rit√© pour userId : metadata / client_reference_id / fallback par customer_id
+    let userId: string | null =
+      (session.metadata as any)?.user_id ||
+      (session.client_reference_id ? String(session.client_reference_id) : null) ||
+      null;
+
+    if (!userId) {
+      const customerId =
+        typeof session.customer === "string" ? session.customer : session.customer?.id;
+      if (customerId) {
+        const { data: found } = await supabaseServer
+          .from("users")
+          .select("id")
+          .eq("stripe_customer_id", customerId)
+          .maybeSingle();
+        userId = found?.id ?? null;
+      }
+    }
+    if (!userId) return res.status(400).json({ error: "user_id introuvable depuis la session" });
 
     // Plan DB
     const { data: plan, error: planError } = await supabaseServer
       .from("subscription_plans")
       .select("id, name, price_monthly")
       .eq("stripe_price_id", priceId)
       .maybeSingle();
     if (planError || !plan) {
       console.error("‚ùå Plan introuvable pour price:", priceId, planError);
       return res.status(404).json({ error: "Plan introuvable" });
     }
 
-    // UPSERT subscriptions par stripe_subscription_id, centr√© user_id
-    const subscriptionRow = {
-      user_id: user.id,
-      plan_id: plan.id, // integer
-      status: "active" as const, // success checkout => actif; webhook affinera
-      stripe_subscription_id: fullSub.id,
-      updated_at: new Date().toISOString(),
-    };
-
-    // Existe d√©j√† ?
-    const { data: existing, error: existErr } = await supabaseServer
-      .from("subscriptions")
-      .select("id, user_id")
-      .eq("stripe_subscription_id", fullSub.id)
-      .maybeSingle();
-
-    if (existErr) {
-      console.error("‚ö†Ô∏è Lookup existing sub err:", existErr);
-    }
-
-    if (existing) {
-      const { error: upErr } = await supabaseServer
-        .from("subscriptions")
-        .update(subscriptionRow)
-        .eq("id", existing.id);
-      if (upErr) console.error("‚ö†Ô∏è Update sub err:", upErr);
-    } else {
-      const { error: insErr } = await supabaseServer
-        .from("subscriptions")
-        .insert(subscriptionRow);
-      if (insErr) console.error("‚ö†Ô∏è Insert sub err:", insErr);
-    }
+    // ‚úÖ UPSERT robuste (stoppe en cas d'erreur)
+    try {
+      await upsertSubscriptionRow({
+        user_id: userId,
+        plan_id: plan.id,
+        status: "active", // le webhook affinera ensuite
+        stripe_subscription_id: fullSub.id,
+        stripe_customer_id:
+          typeof session.customer === "string" ? session.customer : session.customer?.id,
+        current_period_start: tsToIso(fullSub.current_period_start),
+        current_period_end: tsToIso(fullSub.current_period_end),
+      });
+    } catch (e:any) {
+      console.error("‚ùå DB upsert failed in handle-success:", e?.message || e);
+      return res.status(500).json({ error: "DB insert failed" });
+    }
 
     res.json({
       success: true,
-      userId: user.id,
+      userId,
       subscriptionId: fullSub.id,
       planName: plan.name,
     });
   } catch (error) {
     console.error("‚ùå Erreur handle-success:", error);
@@
 // Webhook Stripe (requiert raw body dans Express)
-router.post("/webhook", async (req, res) => {
+router.post("/webhook", express.raw({ type: "application/json" }), async (req, res) => {
   const sig = req.headers["stripe-signature"] as string;
   let event: Stripe.Event;
 
   try {
     event = stripe.webhooks.constructEvent(req.body, sig, process.env.STRIPE_WEBHOOK_SECRET!);
@@
-      case "customer.subscription.created":
-      case "customer.subscription.updated": {
+      case "customer.subscription.created":
+      case "customer.subscription.updated": {
         const s = event.data.object as any;
         const stripeSubId = s.id;
 
         // Compl√©ter statut + dates
         const updates: any = {
@@
-        if (!row?.user_id) {
-          // 1) metadata userId
-          if (s.metadata?.userId) {
-            updates.user_id = s.metadata.userId;
-          } else {
-            // 2) fallback customer -> email -> users.id
-            try {
-              const customer = await stripe.customers.retrieve(s.customer as string);
-              const email = (customer as any)?.email;
-              if (email) {
-                const { data: u } = await supabaseServer
-                  .from("users")
-                  .select("id")
-                  .eq("email", email)
-                  .maybeSingle();
-                if (u?.id) updates.user_id = u.id;
-              }
-            } catch (e) {
-              console.warn("‚ö†Ô∏è Webhook: unable to resolve user_id from customer", e);
-            }
-          }
-        }
+        if (!row?.user_id) {
+          // 1) metadata (cl√© normalis√©e user_id)
+          if (s.metadata?.user_id) {
+            updates.user_id = String(s.metadata.user_id);
+          } else {
+            // 2) fallback customer -> users.stripe_customer_id
+            try {
+              const customerId = typeof s.customer === "string" ? s.customer : s.customer?.id;
+              if (customerId) {
+                const { data: u } = await supabaseServer
+                  .from("users")
+                  .select("id")
+                  .eq("stripe_customer_id", customerId)
+                  .maybeSingle();
+                if (u?.id) updates.user_id = u.id;
+              }
+            } catch (e) {
+              console.warn("‚ö†Ô∏è Webhook: unable to resolve user_id via customer_id", e);
+            }
+          }
+        }
 
         // (optionnel) plan_id via price
         const priceId = s.items?.data?.[0]?.price?.id;
         if (priceId) {
           const planId = await mapPriceToPlanId(priceId);
           if (planId) updates.plan_id = planId;
         }
 
-        await supabaseServer.from("subscriptions")
-          .update(updates)
-          .eq("stripe_subscription_id", stripeSubId);
+        await supabaseServer
+          .from("subscriptions")
+          .update(updates)
+          .eq("stripe_subscription_id", stripeSubId);
 
         break;
       }
