Tu as bien fait de partager √ßa. Le diagnostic Replit est pertinent (email manquant, utilisateur introuvable par email, erreurs silencieuses). Mais le vrai probl√®me est architectural : compter sur /handle-success + customer_details.email est fragile. La solution robuste est :

Ne plus d√©pendre de l‚Äôemail.

Toujours passer user_id √† Stripe (metadata + client_reference_id).

√âcrire en base via le webhook Stripe (pas dans /handle-success).

Si tu veux un correctif imm√©diat (hotfix) sans tout chambouler aujourd‚Äôhui, je te donne deux niveaux:

‚úÖ ‚ÄúBest practice‚Äù (recommand√©) ‚Äî Webhook + metadata
A. Cr√©ation de la session Checkout

Assure-toi que tu passes syst√©matiquement le user_id :

// Dans POST /api/subscriptions/checkout
const session = await stripe.checkout.sessions.create({
  mode: "subscription",
  customer: customerId,            // si tu as d√©j√† le customer
  client_reference_id: user.id,    // <‚Äî IMPORTANT
  metadata: { user_id: user.id, plan_id: String(planId) },
  subscription_data: {
    metadata: { user_id: user.id, plan_id: String(planId) },
  },
  line_items: [{ price: planPriceId, quantity: 1 }],
  success_url: `${APP_URL}/billing/success?session_id={CHECKOUT_SESSION_ID}`,
  cancel_url: `${APP_URL}/billing/cancel`,
});

B. Webhook (/api/stripe/webhook) = seule source d‚Äô√©criture

√âcris/maj la table subscriptions sur checkout.session.completed et customer.subscription.* en lisant metadata.user_id (ou client_reference_id en fallback) :

// pseudo-code compact
if (event.type === "checkout.session.completed") {
  const s = event.data.object as Stripe.Checkout.Session;
  const userId = s.metadata?.user_id || s.client_reference_id;
  const subId = typeof s.subscription === "string" ? s.subscription : s.subscription?.id;

  if (userId && subId) {
    const sub = await stripe.subscriptions.retrieve(subId);
    await upsertSubscription({
      userId,
      stripeSubscriptionId: sub.id,
      stripeCustomerId: typeof s.customer === "string" ? s.customer : s.customer?.id,
      planId: s.metadata?.plan_id ?? null,
      status: sub.status,
      currentPeriodStart: new Date(sub.current_period_start * 1000).toISOString(),
      currentPeriodEnd: new Date(sub.current_period_end * 1000).toISOString(),
    });
  } else {
    console.error("Webhook sans userId ou subId", { userId, subId });
  }
}


Et g√®re aussi customer.subscription.created/updated/deleted pour les mises √† jour de statut.

C. /handle-success : affichage uniquement

Ne fais aucune insertion ici. Juste lire et afficher.

D. Garde-fous SQL
-- Normalise le sch√©ma
ALTER TABLE subscriptions
  ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE subscriptions
  ADD CONSTRAINT subscriptions_stripe_unique UNIQUE (stripe_subscription_id);

CREATE INDEX IF NOT EXISTS idx_subscriptions_user ON subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);

ü©π ‚ÄúHotfix minimal‚Äù ‚Äî si tu dois garder /handle-success aujourd‚Äôhui

Si tu veux seulement corriger le fait que user_id n‚Äôarrive pas tout de suite, applique ces trois patchs (tu pourras migrer vers le webhook ensuite) :

1) Ne bloque plus sur customer_details.email

Remplace la logique ‚Äúemail obligatoire‚Äù par une r√©solution sans email :

// AVANT
const userEmail = session.customer_details?.email;
if (!userEmail) return res.status(400).json({ error: "Email client manquant" });

// APR√àS
const userIdFromMeta = session.metadata?.user_id || session.client_reference_id;
let userId = userIdFromMeta ?? null;

if (!userId) {
  // Fallback via customer -> users.stripe_customer_id
  const customerId = typeof session.customer === "string" ? session.customer : session.customer?.id;
  if (customerId) {
    const { data: found } = await supabaseServer
      .from("users")
      .select("id")
      .eq("stripe_customer_id", customerId)
      .maybeSingle();
    userId = found?.id ?? null;
  }
}

if (!userId) {
  console.error("Impossible de d√©terminer user_id");
  return res.status(400).json({ error: "user_id introuvable" });
}

2) Stopper net si l‚Äôinsertion √©choue

Ne loggue pas ‚Äúsilencieusement‚Äù :

const { error: insErr } = await supabaseServer
  .from("subscriptions")
  .insert(subscriptionRow);

if (insErr) {
  console.error("Insert subscriptions error", insErr, { subscriptionRow });
  return res.status(500).json({ error: "DB insert failed" });
}

3) R√©cup√®re l‚ÄôID de subscription Stripe de fa√ßon s√ªre

Ne t‚Äôappuie pas sur l‚Äôemail : lis la vraie subscription depuis la session :

const subscriptionId = typeof session.subscription === "string"
  ? session.subscription
  : session.subscription?.id;

if (!subscriptionId) {
  return res.status(400).json({ error: "Aucune subscription Stripe associ√©e √† la session" });
}

const sub = await stripe.subscriptions.retrieve(subscriptionId);

const subscriptionRow = {
  user_id: userId,                               // <‚Äî d√©sormais fiable
  stripe_subscription_id: sub.id,
  stripe_customer_id: typeof session.customer === "string" ? session.customer : session.customer?.id,
  plan_id: session.metadata?.plan_id ?? null,
  status: sub.status,
  current_period_start: new Date(sub.current_period_start * 1000).toISOString(),
  current_period_end: new Date(sub.current_period_end * 1000).toISOString(),
  updated_at: new Date().toISOString(),
};


Ce hotfix √©limine compl√®tement la d√©pendance √† customer_details.email et corrige la ligne vide ‚Äúuser_id‚Äù.

Check-list rapide de debug

 Au moment du Checkout : v√©rifie dans ton code que tu passes bien client_reference_id et metadata.user_id.

 Webhook : signature OK, route en express.raw, statut 200 sur checkout.session.completed.

 Logs : plus de Insert sub err silencieux ‚Äî on return res.status(500) sur erreur.

 DB : subscriptions.user_id est NOT NULL + unique sur stripe_subscription_id.

Conclusion

Oui, la r√©ponse de Replit est utile pour identifier o√π √ßa casse.

Pour corriger durablement, passe par metadata user_id + webhook.

Si tu veux d√©bloquer maintenant sans refonte : applique le hotfix ci-dessus dans /handle-success (remplacer l‚Äôemail par metadata.user_id / client_reference_id, stopper sur erreur, lire la vraie subscription Stripe).